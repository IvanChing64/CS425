using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Script for handling movement and attack range
/// </summary>
/// <remarks>by Liam Riel</remarks>
public static class RangeManager
{
    public static Dictionary<Tile, Tile> GetPathsInRange(Tile startTile, int range, RangeType type = RangeType.Flood)
    {
        switch (type)
        {
            case RangeType.Bypass:
                return GetPathsBypass(startTile, range);
            case RangeType.Flood:
                return GetPathsFlood(startTile, range);
            case RangeType.Orthogonal:
                return GetPathsOrthogonal(startTile, range);
            case RangeType.Diagonal:
                return GetPathsDiagonal(startTile, range);
            default:
                Debug.LogError("Invalid range type.");
                return null;
        }
    }

    public static List<Tile> GetTilesInRange(Tile startTile, int range, RangeType type = RangeType.Flood) =>
        GetPathsInRange(startTile, range, type).Keys.ToList();

    public static int DistanceBetween(Tile fromTile, Tile toTile)
    {
        int xDiff = Math.Abs((int)fromTile.Position.x - (int)toTile.Position.x);
        int yDiff = Math.Abs((int)fromTile.Position.y - (int)toTile.Position.y);

        return xDiff + yDiff;
    }

    /// <summary>
    /// <para>Uses the dictionary created by GetPathsInRange to create the proper path to a tile</para>
    /// </summary>
    /// <param name="targetTile">The tile to find a path to</param>
    /// <param name="tilePaths">A dictionary of tiles (keys) and the tiles that precede them (value), generated by GetPathsInRange</param>
    /// <returns>A path to the target tile based on the path dictionary</returns>
    public static List<Tile> ReconstructPath(Tile targetTile, Dictionary<Tile, Tile> tilePaths)
    {
        if (!tilePaths.ContainsKey(targetTile))
        {
            Debug.LogError("Path reconstruction failed, target tile is not a key in paths dictionary");
            return null;
        }

        List<Tile> path = new() { targetTile };

        while (tilePaths.TryGetValue(path[0], out Tile fromTile))
        {
            path.Insert(0, fromTile);
        }

        return path;
    }

    private static Dictionary<Tile, Tile> GetPathsBypass(Tile startTile, int range)
    {
        Dictionary<Tile, Tile> tilePathsInRange = new();
        Queue<Tile> visitQueue = new();
        visitQueue.Enqueue(startTile);

        tilePathsInRange.Add(startTile, null);

        while (visitQueue.TryDequeue(out Tile visitedTile))
        {
            foreach (Tile neighbor in visitedTile.Neighbors.Where(t => !tilePathsInRange.Keys.Contains(t) && DistanceBetween(startTile, t) <= range))
            {
                tilePathsInRange.Add(neighbor, visitedTile);
                visitQueue.Enqueue(neighbor);
            }
        }

        tilePathsInRange.Remove(startTile);

        return tilePathsInRange;
    }

    private static Dictionary<Tile, Tile> GetPathsFlood(Tile startTile, int range)
    {
        Dictionary<Tile, Tile> tilePathsInRange = new();
        Queue<Tile> visitQueue = new();
        visitQueue.Enqueue(startTile);

        // Constrain the total number of moves made to the range
        for (int i = 0; i < range; i++)
        {
            Queue<Tile> addQueue = new();

            while (visitQueue.TryDequeue(out Tile visitedTile))
            {
                foreach (Tile neighbor in visitedTile.Neighbors.Where(t => !tilePathsInRange.Keys.Contains(t) && t.Walkable))
                {
                    tilePathsInRange.Add(neighbor, visitedTile);
                    addQueue.Enqueue(neighbor);
                }
            }

            while (addQueue.TryDequeue(out Tile nextTile))
            {
                visitQueue.Enqueue(nextTile);
            }
        }

        return tilePathsInRange;
    }

    private static Dictionary<Tile, Tile> GetPathsOrthogonal(Tile startTile, int range)
    {
        throw new NotImplementedException();

        //Dictionary<Tile, Tile> tilePathsInRange = new();
        //return tilePathsInRange;
    }

    private static Dictionary<Tile, Tile> GetPathsDiagonal(Tile startTile, int range)
    {
        throw new NotImplementedException();

        //Dictionary<Tile, Tile> tilePathsInRange = new();
        //return tilePathsInRange;
    }
}

public enum RangeType
{
    /// <summary>Range moves one tile in any orthogonal direction at a time for its total range, ignoring blockers</summary>
    Bypass,

    /// <summary>Range moves one tile in any orthogonal direction at a time for its total range, respecting blockers</summary>
    Flood,

    /// <summary>Range moves for up to a set number of tiles in a singular orthogonal direction, respecting blockers</summary>
    Orthogonal,

    /// <summary>Range moves for up to a set number of tiles in a singular diagonal direction, respecting blockers</summary>
    Diagonal
}