using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Script for handling movement and attack range
/// </summary>
/// <remarks>Primary author: Liam Riel</remarks>
public static class RangeManager
{
    public static Dictionary<Tile, Tile> GetPathsInRange(Tile startTile, int range, RangeType type = RangeType.FloodMovement)
    {
        switch (type)
        {
            case RangeType.FloodMovement:
                return GetPathsFlood(startTile, range, false);
            case RangeType.FloodTargeting:
                return GetPathsFlood(startTile, range, true);
            default:
                Debug.LogError("Invalid range type.");
                return null;
        }
    }

    /// <summary>
    /// Gets all tiles in a certain range of another tile using a certain range type
    /// </summary>
    /// <param name="startTile">The tile to begin the search from</param>
    /// <param name="range">The maximum number of tiles away to search from startTile</param>
    /// <param name="type">The type of range to check, whether for movement, unit targeting, etc.</param>
    /// <returns>A list of all the tiles in range of the starting </returns>
    public static List<Tile> GetTilesInRange(Tile startTile, int range, RangeType type = RangeType.FloodMovement) =>
        GetPathsInRange(startTile, range, type).Keys.ToList();

    /// <summary>
    /// Finds the distance between two tiles in terms of the number of orthogonal single-tile moves it would take to reach one from the other
    /// </summary>
    /// <param name="fromTile">The tile to find the distance from</param>
    /// <param name="toTile">The tile to find the distance to</param>
    /// <returns>The number of tile moves it would take to move between the parameter tiles</returns>
    public static int DistanceBetween(Tile fromTile, Tile toTile)
    {
        int xDiff = Math.Abs((int)fromTile.Position.x - (int)toTile.Position.x);
        int yDiff = Math.Abs((int)fromTile.Position.y - (int)toTile.Position.y);

        return xDiff + yDiff;
    }

    /// <summary>
    /// <para>Uses the dictionary created by GetPathsInRange to create the proper path to a tile</para>
    /// </summary>
    /// <param name="targetTile">The tile to find a path to</param>
    /// <param name="tilePaths">A dictionary of tiles (keys) and the tiles that precede them (value), generated by GetPathsInRange</param>
    /// <returns>A path to the target tile based on the path dictionary</returns>
    public static List<Tile> ReconstructPath(Tile targetTile, Dictionary<Tile, Tile> tilePaths)
    {
        if (!tilePaths.ContainsKey(targetTile))
        {
            Debug.LogError("Path reconstruction failed, target tile is not a key in paths dictionary");
            return null;
        }

        List<Tile> path = new() { targetTile };

        while (tilePaths.TryGetValue(path[0], out Tile fromTile))
        {
            path.Insert(0, fromTile);
        }

        return path;
    }

    private static Dictionary<Tile, Tile> GetPathsFlood(Tile startTile, int range, bool ignoreOccupation = false, bool ignoreBlockers = false)
    {
        Dictionary<Tile, Tile> tilePathsInRange = new();
        Queue<Tile> visitQueue = new();
        visitQueue.Enqueue(startTile);

        // Constrain the total number of moves made to the range
        for (int i = 0; i < range; i++)
        {
            Queue<Tile> addQueue = new();

            while (visitQueue.TryDequeue(out Tile visitedTile))
            {
                foreach (Tile neighbor in visitedTile.Neighbors.Where(t => !tilePathsInRange.Keys.Contains(t) && (ignoreBlockers || t.isWalkable) && (ignoreOccupation || t.OccupiedUnit == null)))
                {
                    tilePathsInRange.Add(neighbor, visitedTile);
                    addQueue.Enqueue(neighbor);
                }
            }

            while (addQueue.TryDequeue(out Tile nextTile))
            {
                visitQueue.Enqueue(nextTile);
            }
        }

        return tilePathsInRange;
    }
}

/// <summary>
/// Enum for different ways of searching in a range. Even types are movement-oriented, odd types are targeting oriented
/// </summary>
public enum RangeType
{
    /// <summary>Range type for movement that respects blockers and occupied tiles</summary>
    FloodMovement,

    /// <summary>Range type for targeting that respects blockers</summary>
    FloodTargeting
}
