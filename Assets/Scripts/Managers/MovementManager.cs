using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// <para>Script for handling player movements</para>
/// </summary>
/// <remarks>by Liam Riel</remarks>
public class MovementManager : MonoBehaviour
{
    public static MovementManager Instance;

    private void Awake()
    {
        Instance = this;
    }

    /// <summary>
    /// <para>Gets all tiles within a certain range of another tile</para>
    /// </summary>
    /// <param name="startTile">The tile to search from</param>>
    /// <param name="range">The maximum range to search for tiles away from startTile</param>
    /// <returns>A list with all found tiles in range of the starting tile</returns>
    public List<Tile> GetTilesInRange(Tile startTile, int range)
    {
        List<Tile> tilesInRange = new();
        Queue<Tile> visitQueue = new();

        visitQueue.Enqueue(startTile);

        while (visitQueue.TryDequeue(out Tile visitedTile))
        {
            foreach (Tile neighbor in visitedTile.Neighbors.Where(t => !tilesInRange.Contains(t) && t.Walkable && DistanceBetween(startTile, t) <= range))
            {
                tilesInRange.Add(neighbor);
                visitQueue.Enqueue(neighbor);
            }
        }

        return tilesInRange;
    }

    /// <summary>
    /// <para>Gets all tiles within a certain range of another tile with the ability to reconstruct a path to that tile</para>
    /// </summary>
    /// <param name="startTile">The tile to search from</param>>
    /// <param name="range">The maximum range to search for tiles away from startTile</param>
    /// <returns>A dictionary of all found tiles (key) paired with the tile that precedes them (value) in range of the starting tile</returns>
    public Dictionary<Tile, Tile> GetPathsInRange(Tile startTile, int range)
    {
        Dictionary<Tile, Tile> tilePathsInRange = new();
        Queue<Tile> visitQueue = new();

        tilePathsInRange.Add(startTile, null);
        visitQueue.Enqueue(startTile);

        while (visitQueue.TryDequeue(out Tile visitedTile))
        {
            foreach (Tile neighbor in visitedTile.Neighbors.Where(t => !tilePathsInRange.Keys.Contains(t) && t.Walkable && DistanceBetween(startTile, t) <= range))
            {
                tilePathsInRange.Add(neighbor, visitedTile);
                visitQueue.Enqueue(neighbor);
            }
        }

        // The start tile should not be 'reachable' from itself, b/c that could cause problems with path reconstruction later
        tilePathsInRange.Remove(startTile);
        
        return tilePathsInRange;
    }

    /// <summary>
    /// <para>Finds the distance between two tiles in terms of the number of orthogonal single-tile moves it would take to reach one from the other</para>
    /// </summary>
    /// <param name="fromTile">The tile to find the distance from</param>
    /// <param name="toTile">The tile to find the distance to</param>
    /// <returns>The number of tile moves it would take to move between the parameter tiles</returns>
    public int DistanceBetween(Tile fromTile, Tile toTile)
    {
        int xDiff = Math.Abs((int)fromTile.Position.x - (int)toTile.Position.x);
        int yDiff = Math.Abs((int)fromTile.Position.y - (int)toTile.Position.y);

        return xDiff + yDiff;
    }

    /// <summary>
    /// <para>Uses the dictionary created by GetPathsInRange to create the proper path to a tile</para>
    /// </summary>
    /// <param name="targetTile">The tile to find a path to</param>
    /// <param name="tilePaths">A dictionary of tiles (keys) and the tiles that precede them (value), generated by GetPathsInRange</param>
    /// <returns>A path to the target tile based on the path dictionary</returns>
    public List<Tile> ReconstructPath(Tile targetTile, Dictionary<Tile, Tile> tilePaths)
    {
        if (!tilePaths.ContainsKey(targetTile))
        {
            Debug.LogError("Path reconstruction failed, target tile is not a key in paths dictionary");
            return null;
        }

        List<Tile> path = new() { targetTile };

        while (tilePaths.TryGetValue(path[0], out Tile fromTile))
        {
            path.Insert(0, fromTile);
        }

        return path;
    }
}
